# 6. 물리적 데이터베이스 설계

### 물리적 데이터베이스 설계

- 논리적인 설계의 데이터 구조를 보조 기억 장치상의 화일(물리적인 데이터 모델)로 사상함
- 예상 빈도를 포함하여 데이터베이스 질의와 트랜잭션들을 분석함
- 데이터에 대한 효율적인 접근을 제공하기 위하여 저장 구조와 접근 방법들을 다룸
- 특정 DBMS의 특성을 고려하여 진행됨
- 질의를 효율적으로 지원하기 위해서 인덱스 구조를 적절히 사용

### 1. 보조 기억 장치

- 사용자가 원하는 데이터를 검색하기 위해서 DBMS는 디스크 상의 데이터베이스로부터 사용자가 원하는 데이터를 포함하고 있는 블록을 읽어서 주기억 장치로 가져옴
- 데이터가 변경된 경우에는 블록들을 디스크에 다시 기록함
- 블록 크기는 512바이트부터 수 킬로 바이트까지 다양함
- 전형적인 블록 크기는 4,096바이트
- 각 화일은 고정된 크기의 블록들로 나누어져서 저장됨
- 디스크는 데이터베이스를 장기간 보관하는 주된 보조 기억 장치

- 저장 장치의 계층 구조

![Untitled](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/40f1b130-53af-4d30-a314-b03d6f8a4bc6)


- **자기 디스크**
    - 디스크는 자기 물질로 만들어진 여러 개의 판으로 이루어짐
    - 각 면마다 디스크 헤드가 있음
    - 각 판은 **트랙**과 **섹터**로 구분됨
    - 정보는 디스크 표면 상의 트랙을 따라 저장됨
    - 여러 개의 디스크 면 중에서 같은 지름을 갖는 트랙들을 **실린더**라고 부름
        - 헤드를 움직이지 않고  한 릴레이션을 한 실린더에 저장하여 읽어오면 가장 빠르게 읽어올 수 있음
    - 블록은 한 개 이상의 섹터들로 이루어짐
    - `디스크에서 임의의 블록을 읽어오거나 기록하는데 걸리는 시간 = 
    **탐구 시간(seek time), 회전 지연 시간(rotational delay), 전송 시간(transfer time)**의 합`
        - 탐구 시간이 제일 오래 걸림
        - random access : 어디에서 데이터에 접근하던지 같은 속도를 보장하는 것
    

### 2. 버퍼 관리와 운영 체제

- 버퍼 관리와 운영 체제
    - 디스크 입출력은 컴퓨터 시스템에서 가장 속도가 느린 작업이므로 입출력 횟수를 줄이는 것이 DBMS의 성능을 향상하는데 매우 중요
    - 가능하면 많은 블록들을 주기억 장치에 유지하거나, 자주 참조되는 블록들을 주기억 장치에 유지하면 블록 전송 횟수를 줄일 수 있음
    - **버퍼**는 디스크 블록들을 저장하는데 사용되는 주기억 장치 공간
    - 버퍼 관리자는 운영 체제의 구성요소로서 주기억 장치 내에서 버퍼 공간을 할당하고 관리하는 일을 맡음
    - 운영 체제에서 버퍼 관리를 위해 흔히 사용되는 **LRU** 알고리즘은 데이터 베이스를 위해 항상 우수한 성능을 보이지는 않음
        - LRU : 가장 최근에 사용하지 않은 버퍼 버림
        
        ![Untitled 1](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/652e6e76-4990-4105-ae55-325c57ee74d5)

        
        - Data는 DBMS의 실행을 하려면 RAM에 있어야함
        - 테이블의 <frame#, pageid> 페어는 유지되어야함
        

### 3. 디스크 상에서 화일의 레코드 배치

- 디스크 상에서 화일의 레코드 배치
    - 릴레이션의 애트리뷰트는 고정 길의 또는 가변 길이의 필드로 표현됨
    - 연관된 필드들이 모여서 고정 길이 또는 가변 길이의 레코드가 됨
    - 한 릴레이션을 구성하는 레코드들의 모임이 화일이라고 부르는 블록들의 모임에 저장됨
    - 화일과 블록과 레코드
        
        ![Untitled 2](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/dc491659-717c-4d7b-9eb0-b8c4c6f7c90a)

        
    - 한 화일에 속하는 블록들이 반드시 인접해 있을 필요는 없음
    - 인접한 블록들을 읽는 경우에는 탐구 시간과 회전 지연 시간이 들지 않기 때문에 입출력 속도가 빠르므로 블록들이 인접하도록 한 화일의 블록들을 재조직할 수 있음
    - 디스크에서 블록들의 연결 ( linkedlist 이용, pointer)
        
        ![Untitled 3](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/bd83c501-8f70-4f87-914f-d9ee3f77867c)

        

- **BLOB(Binary Large Object)**
    - 이미지, 동영상 등 대규모 크기의 데이터를 저장하는데 사용됨
    - BLOB의 최대 크기는 MS SQL Server에서 2GB까지도 가능

- 채우기 인수
    
    ![Untitled 4](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/b73433e8-f882-4758-9b25-75b69e378ae6)

    
    - 각 블록에 레코드를 채우는 공간의 비율
    - 나중에 레코드가 삽입될 때 기존의 레코드들을 이동하는 가능성을 줄이기 위해서

- **고정 길이 레코드**
    - 레코드 i를 접근하기 위해서는 `n*(i-1)+1` 의 위치에서 레코드를 읽음
        
        
        ![Untitled 5](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/d3ead9cc-95c6-44dc-8c62-0c1337ab316a)

        
        ![Untitled 6](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/e5bcbd1f-a303-4d15-b910-cec6d6260684)

        
- 화일 내의 클러스터링(intra-file clustering)
    - 한 화일 내에서 함께 검색될 가능성이 높은 레코드들은 디스크 상에서 물리적으로 가까운 곳에 모아두는 것
        
        ![Untitled 7](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/fbd08324-85a8-42e9-8d1f-134fda65bb79)

        
- 화일 간의 클러스터링(inter-file clustering)
    - 논리적으로 연관되어 함께 검색될 가능성이 높은 두 개 이상의 화일에 속한 레코드들을 디스크 상에서 물리적으로 가까운 곳에 저장하는 것
        
        ![Untitled 8](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/d6c79431-3776-4fea-9809-96ff7ef65b34)

        

### 4. 화일 조직

- 화일 조직의 유형
    - heap file : 히프 화일
    - sequential file : 순차 화일
    - indexed  sequential file : 인덱스된 순차 화일
    - hash file : 직접 화일

- heap file (비순서 화일)
    - 가장 단순한 화일 조직
    - 일반적으로 레코드들이  삽입된 순서대로 화일에 저장됨
    - 삽입(append) :  새로 삽입되는 레코드는 화일의 가장 끝에 첨부됨
    - 검색 : 원하는 레코드를 찾기 위해서는 모든 레코드들을 순차적으로 접근해야함
    - 삭제 : 원하는 레코드를 찾은 후에 그 레코드를 삭제하고, 삭제된 레코드가 차지하던 공간을 재사용하지 않음
    - 성능
        - 모든 레코드들을 참조하고, 레코드들을 접근하는 순서는 중요하지 않알 때
            
            `select * from employee;`
            
        - 특정 레코드를 검색하는 경우에는 히프 화일이 비효율적
            - 히프 화일이 b개의 블록이 있다고 가정할 때, 원하는 블록을 찾기 위해서 평균적으로 b/2개의 블록을 읽어야함
                
                `select title from employee where empno = 1356;`
                
        - 몇 개의 레코드들을 검색하는 경우에도 비효율적
        
        ![Untitled 9](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/4deac286-4209-4863-83fe-075fa2fd199f)

        
    - 좋은 성능을 유지하기 위해서 히프 화일을 주기적으로 재조직할 필요가 있음
    → 삭제된 파일들 공간 재조직
        
        ![Untitled 10](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/b8e582ba-f214-4602-a429-b226b39e5701)

        
    - 예)
        
        ![Untitled 11](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/1623f4a0-bf7d-48df-9ac7-76f0a3ed6781)

        
        ⇒ 특수한 경우에만 사용,
        
- **순차 화일**
    - 레코드들이 하나 이상의 필드 값에 따라 순서대로 저장된 화일
    - 레코드들이 일반적으로 레코드의 **탐색 키(search key)** 값의 순서에 따라 저장됨
    - 탐색 키는 순차 화일을 정렬하는데 사용되는 필드를 의미
    - 삽입 : 삽입하려는 레코드의 순서를 고려해야 하기 때문에 시간이 많이 걸릴 수 있음
    - 삭제 : 삭제된 레코드가 사용하던 공간을 빈 공간으로 남기기 때문에 히프 화일의 경우와 마찬가지로 주기적으로 순차 화일을 재조직해야 함
    - 성능 (empno 기준으로 저장되어 있음)
        - 순서대로 저장되어 있을 때 → 이진 탐색
            
            `select title from employ where empno = 1365;`
            
        - 저장 순서와 무관할 때 → 전체 화일을 탐색해야함
            
            `select title, empname from employ where salary > 30000 and salary < 40000;`
            
        
        ![Untitled 12](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/2380d57d-93e9-4958-b0c6-87f1bc5e71c8)

        
    - 기본 인덱스가 순차 화일에 정의되지 않은 한 순차 화일은 데이터베이스 응용을 위해 거의 사용되지 않음
        
        ![Untitled 13](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/15df4842-0bac-4dca-bf6b-a54e40600711)

        

### 5. 단일 단계 인덱스

- 단일 단계 인덱스
    - 인덱스된 순차 화일은 인덱스를 통해서 임의의 레코드를 접근할 수 있는 화일
    - 단일 단계 인덱스의 각 엔트리는 **`<탐색 키, 레코드에 대한 포인터>`**
    - 엔트리들은 탐색 키 값의 오름차순으로 정렬됨
        
        ![Untitled 14](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/c3a288fa-6755-4423-b9c3-4fb2f0bc854b)

        
    - 인덱스는 데이터 화일과는 별도의 화일에 저장됨
    - 인덱스의 크기는 데이터 화일의 크기에 비해 훨씬 작음
    - 하나의 화일에 여러 개의 인덱스들을 정의할 수 있음
        
        ![Untitled 15](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/99c70ac9-6b46-41ee-ad5f-408b5cd56aa7)

        
    - 인덱스가 정의된 필드를 **탐색 키** 라고 함
    - 탐색 키의 값들은 후보 키 처럼 각 튜플마다 반드시 고유하지는 않음
    - 키를 구성하는 애트리뷰트뿐만 아니라 어떤 애트리뷰트도 탐색 키로 사용될 수 있음
        
        → 도메인 카디널리티를 고려하여 만드는 것이 좋음
        
    - 인덱스의 엔트리들은 탐색 키 값의 오름차순으로 저장되어 있으므로 이진 탐색을 이용할 수도 있음
    
    - 기본 인덱스(primary index)
        - 탐색 키가 데이터 화일의 기본 키인 인덱스를 기본 인덱스라고 부름
        - 기본 인덱스는 기본 키의 값에 따라 정렬된 데이터 화일에 대해 정의됨
        - 기본 인덱스는 흔히 희소 인덱스로 유지할 수 있음( → 키값이 sorting이 되어 있어야 함)
        - 각 릴레이션 마다 최대한 한 개의 기본 인덱스를 가질 수 있음
            
            ![Untitled 16](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/97d9afe1-36c3-46d7-b447-8f6a3ab3192c)

            
            기본(희소) 인덱스 → 20개의 레코드에 1개의 인덱스만 만든다.
            
        - ex) 단일 단계 인덱스
            
            ![Untitled 17](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/a5adb9a9-f346-4c31-8828-2ec4162416b7)

            
            블록 3000개로 인덱스 생성 가능
            
- 클러스터링 인덱스(clustering index)
    - 탐색 키 값에 따라 정렬된 데이터 화일에 대해 정의 됨
    - 각각의 상이한 키 값 마다 하나의 인덱스 엔트리가 인덱스에 포함됨
    - 범위 질의에 유용
    - 범위의 시작 값에 해당하는 인덱스 엔트리를 먼저 찾고, 범위에 속하는 인덱스 엔트리들을 따라가면서 레코드들을 검색할 때 디스크에서 읽어오는 블록 수가 최소화 됨
    - 어떤 인덱스 엔트리에서 참조되는 데이터 블록을 읽어오면 그 데이터 블록에 들어 있는 대부분의 레코드들은 범위에 만족함
        
        ![Untitled 18](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/c7c7eec8-08d0-4517-9817-487aa61b4971)

        
        → 비 클러스터링 인덱스 ?? 이해 못함..
        
    - ex)
        
        ![Untitled 19](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/46182ddb-7e19-478e-9c7f-371e3e61d85a)

        
- 보조 인덱스(secondary index)
    - 한 화일은 기껏해야 한 가지 필드들의 조합에 대해서만 정렬될 수 있음
    - 보조 인덱스는 탐색 키 값에 따라 정렬되지 않은 데이터 화일에 대해 정의 됨
    - 보조 인덱스는 일반적으로 밀집 인덱스이므로 같은 수의 레코드들을 접근할 때 보조 인덱스를 통하면 기본 인덱스를 통하는 경우보다 디스크 접근 횟수가 증가할 수 있음
        
        
        ![Untitled 20](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/5af8171a-a980-4b5f-a8dc-81b087a865fb)

        
        보조(밀집)인덱스
        
        ![Untitled 21](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/43d583c3-6f3d-485d-861f-1198f8851516)

        
        데이터 화일에 대한 밀집 인덱스
        
    - ex)
        
        ![Untitled 22](https://github.com/SSAFY-CSStudy/DataBase/assets/101400650/ef1b3a3b-c118-45e4-9e08-239749e4d9bb)

        
- 희소 인덱스와 밀집 인덱스의 비교
    
    
    | 희소(기본) 인덱스 | 밀집(보조) 인덱스 |
    | --- | --- |
    | 각 데이터 블록 마다 한 개의 엔트리르 갖는다 | 각 레코드 마다 한 개의 엔트리를 가짐 |
    | 레코드의 길이가 블록 크기보다 훨씬 작은 일반적인 경우에는 희소 인덱스의 수가 밀집 인덱스의 엔트리 수보다 휠씬 적음 |  |
    | 인덱스 수가 밀집 인덱스에 비해 1정도 적으므로 인덱스 탐색시 디스크 접근 수가 1만큼 적을 수 있음 |  |
    | 밀집 인덱스에 비해 모든 갱신과 대부분의 질의에 대해 더 효율적 | 질의에서 인덱스가 정의된 애트리뷰트만 검색하는 경우(count 연산)에는 데이터 화일을 접근할 필요가 없이 인덱스만 접근해서 질의를 수행할 수 있으므로 밀집 인덱스가 더 유리 |
    | 한 화일은 한 개의 희소 인덱스와  | 다수의 밀집 인덱스를 가질 수 있다 |
    
- 클러스터링 인덱스와 보조 인덱스의 비교
    - 클러스터링 인덱스는 희소 인덱스일 경우가 많으며 범위 질의 등에 좋음
    - 보조 인덱스는 밀집 인덱스이므로 일부 질의에 대해서는 화일을 접근할 필요가 없이 처리할 수 있음
