# 7. 다단계 인덱스

## 6장 물리적 데이터베이스 설계(계속)

### 다단계 인덱스

- **다단계 인덱스**
    - 인덱스 자체가 클 경우에는 인덱스를 탐색하는 시간도 오래 걸릴 수 있음
    - 인덱스 엔드리를 탐색하는 시간을 줄이기 위해서 단일 계단 인덱스를 디스크 상의 하나의 순서 화일로 간주하고, 단일 단계 인덱스에 대해서 다시 인덱스를 정의할 수 있음
    - 다단계 인덱스는 가장 상위 단계의 모든 인덱스 엔트리들이 한 블록에 들어갈 수 있을 때까지 이런 과정을 반복함
    - 가장 상위 단계 인텍스를 **마스터 인덱스(master index)**라고 부름
    - 마스터 인덱스는 한 블록으로 이루어 지기 때문에 주기억 장치에 상주할 수 있음
    - 대부분의 다단계 인덱스는 **B+ 트리**를 사용
        
        ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled.png)
        
        - 1단계 인덱스의 각각의 블록 중 가장 작은 key 값을 사용해서 2단계 희소 인덱스를 만든다.
        - 전체 블록 I/O ⇒ 4번 (4개의 블록만 읽으면 됨)
        - **trade off**
            - 레코드가 insert, delete, update 가 발생하면 전체적인 구조를 변경해야 함 ⇒ overhead 많이 발생할 수 있음
            - 편향된 트리가 발생할 수 있음 
            ⇒ 보완 : **b+ 트리(balanced tree :** root → leaf노드들의 depth가 다 같음, child를 균일하게 가짐**)**
    - ex) 기본키에 대한 다단계 인덱스
        
        ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%201.png)
        
    
- **SQL의 인덱스 정의문**
    - SQL의 CREATE TABLE 문에서 **PRIMARY KEY** 절로 명시한 애트리뷰트에 대해서는 DBMS가 자동적으로 기본 인덱스르 생성
    - UNIQUE로 명시한 애트리뷰트에 대해서는 DBMS가 자동적으로 보조 인덱스를 생성
    - SQL2는 인덱스 정의 및 제거에 관한 표준 SQL문을 제공하지 않음
    - 다른 애트리뷰트에 추가로 인덱스를 정의하기 위해서는 DBMS마다 다소 구문이 다른 CREATE INDEX 문을 사용해야함
    
- **다수의 애트리뷰트를 사용한 인덱스 정의**
    - 한 릴레이션에 속하는 두 개 이상의 애트리뷰트들의 조합에 대하여 하나의 인덱스를 정의할 수 있음
    - ex ) `CREATE INDEX EmpIndex ON EMPLOYEE (DNO, SALARY);`
        - `SELECT * FROM EMPLOYEE WHERE DNO = 3 AND SALARY = 4000000;`  활용될 수 있음
        - `SELECT * FROM EMPLOYEE WHERE DNO ≥ 2 AND DNO ≤ 3 AND SALARY ≥ 3000000 AND SALARY ≤ 4000000;`  활용될 수 있음
        - `SELECT * FRIN EMPLOYEE WHERE SALARY ≥ 3000000 AND SALARY ≤ 4000000;` 
        활용될 수 없음 ⇒ DNO 없이 SALARY로 만으로는 찾을 수 없음, DNO 단독은 가능

- **인덱스의 장점과 단점**
    - 인덱스는 검색 속도를 향상시키지만 인덱스를 저장하기 위한 공간이 추가로 필요하고 삽입, 삭제, 수정 연산의 속도는 저하시킴
    - 소수의 레코드들을 수정하거나 삭제하는 연산의 속도는 향상됨
    - 릴레이션이 매우 크고 , 질의에서 릴레이션의 튜플들 중에 일부(예, 2%~4%)를 검색하고, WHERE 절이 잘 표현되었을 때 특히 성능에 도움이 됨
    

### 인덱스 선정 지침과 데이터베이스 튜닝

- **인덱스 선정 지침과 데이터베이스 튜닝**
    - 가장 중요한 질의들과 이들의 수행 빈도, 가장 중요한 갱신들과 이들의 수행 빈도, 이와 같은 질의와 갱신들에 대한 바람직한 성능들을 고려하여 인덱스를 선정함
    - 워크로드 내의 각 질의에 대해 이 질의가 어떤 릴레이션들을 접근하는가, 어떤 애트리뷰트들이 포함되는가, 이 조건들의 선별력은 얼마인가 등을 고려함
    - 워크로드 내의 각 갱신에 대해 이 갱신이 어떤 릴레이션들을 접근하는가, WHERE 절의 선택/조인 조건에 어떤 애트리뷰트들이 포함되는가, 이 조건들의 선별력은 얼마인가, 갱신의 유형(INSERT, DELETE, UPDATE), 갱신의 영향을 받는 애트리뷰트 등을 고려함
    - 어떤 릴레이션에 인덱스를 생성하야 하는가, 어떤 애트리뷰트를 탐색키로 선정해야 하는가, 몇 개의 인덱스를 생성해야 하는가, 각 인덱스에 대해 클러스터링 인덱스, 밀집 인덱스/희소 인덱스 중 어느 유형을 선택할 것인가 등을 고려함
    - 인덱스를 선정하는 한 가지 방법은 가장 중요한 질의들로 차례로 고려해보고, 인덱스를 추가하면 더 좋은 계획이 가능한지 알아봄
    - 물리적 데이터베이스 설계는 끊임없이 이루어지는 작업
    - **지침**
        
        ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%202.png)
        
        ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%203.png)
        
- **언제 인덱스가 사용되지 않는가?**
    - 시스템 카탈로그가 오래 전의 데이터베이스 상태를 나타냄 (REAL TIME이 아님)
    → 카탈로그 : 메타 데이터로 로그가 찍혀있음
    - DBMS의 질의 최적화 모듈이 릴레이션의 크기가 작아서 인덱스가 도움이 되지 않는다고 판단함
    - 인덱스가 정의된 애트리뷰트에 산술연산자가 사용됨
        - `SELECT * FROM EMPLOYEE WHERE SALARY * 12 > 400000;`
    - DBMS가 제공하는 내장 함수가 집단 함수 대신에 사용됨
        - `SELECT * FROM EMPLOYEE WHERE SUBSTRING(EMPNAME, 1, 1) = ‘김’;`
    - NULL 값에 대해서는 일반적으로 인덱스가 사용되지 않음
    
- 질의 튜닝을 위한 추가 지침
    - DISTINCT절의 사용을 최소화 하라
    - GROUP BY 절과 HAVING 절의 사용을 최소화 하라
    - 임시 릴레이션의 사용은 피하라
    - SELECT * 대신에 SELECT 절의 애트리뷰트 이름들을 구체적으로 명시하라

### B+ TREE

![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%204.png)

![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%205.png)

![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%206.png)

![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%207.png)

![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%208.png)

## 7장 릴레이션 정규화

### 릴레이션 정규화

- 릴레이션 정규화
    - 부주의한 DB 설계는 제어할 수 없는 데이터 중복을 야기하여 여러가지 **갱신 이상(UPDATE ANOMALY)**을 유발함
    - **정규화**는 주의진 릴레이션 스키마를 함수적 종속성과 기본키를 기반으로 분석하여, 원래의 릴레이션을 분해함으로써 중복과 세 가지 갱신 이상을 최소화함

**갱신 이상**

- 수정 이상 : 반복된 데이터 중에 일부만 수정하면 데이터의 불일치가 발생
- 삽입 이상 : 불필요한 정보를 함께 저장하지 않고는 정보를 저장하는 것이 불가능
- 삭제 이상 : 유용한 정보를 함께 삭제하지 않고는 어떤 정보를  삭제하는 것이 불가능

- **정규형의 종류**
    - 제1정규형, 제2정규형, 제3정규형, BCNF, 제4정규형, 제5정규형
    - 일반적으로 BCNF 까지만 고려
    

### 함수적 종속성

- **함수적 종속성의 개요**
    - 릴레이션 애트리뷰트들의 의미로부터 결정됨
    - 릴레이션 스키마에 대한 주장
    - 릴레이션의 가능한 모든 인스턴스들이 만족해야함
    - 실세계에 대한 지식과 응용의 의미를 기반으로 어떤 함수적 종속성들이 존재하는가를 파악해야함
    - 함수적 종속성은 제2정규형 부터 BCNF 까지 적용됨

- **결정자**
    - 어떤 애트리뷰트의 값은 다른 애트리뷰트의 값을 고유하게 결정할 수 잇음
    - 주소는 사원 이름을 고유하게 결정하지 못함
    - 결정자는 주어진 릴레이션에서 다른 애트리뷰트를 고유하게 결정하는 하나 이상의 애트리뷰트를 의미
    - `A → B` :  A가 B를 결정한다.
        
        ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%209.png)
        
- **완전 함수 종속성(FFD : Full Functional Dependency)**
    - 주어진 릴레이션 R에서 애트리뷰트 B가 애트리뷰트 A에 함수적으로 종속하지 않으면서 애트리뷰트 A의 어떠한 진부분 집합에도 함수적으로 종속하지 않으면 애트리뷰트 B가 애트리뷰트 A에 완전하게 함수적으로 종속한다고 말함 
    (A = 복합 애트리뷰트)
        
        ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%2010.png)
        
- **부분 함수 종속성**
- **이행적 함수 종속성(transitive FD)**
    - 한 릴레이션의 애트리뷰트 A, B, C가 주어졌을 때 애트리뷰트 C가 이행적으로 A에 종속한다 (A → C)는 것이 필요 충분 조건은 `A → B ^ B → C` 가 성립하는 것
    - A가 릴레이션의 기본 키라면 키의 정의에 따라 `A → B`와 `A → C`가 성립. 만일 C가 A외에 B에도 함수적으로 종속한다면 C는 A에 직접 함수적으로 종속하면서 B를 거쳐서 A에 이행적으로 종
        
        ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%2011.png)
        

### 릴레이션 분해

- **릴레이션 분해**
    - 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것
    - 릴레이션을 분해하면 중복이 감소되고 갱신 이상이 줄어드는 장점이 있는 **반면**,
     바람직하지 않은 문제들을 포함하여 몇 가지 잠재적인 문제들을 야기할 수 있음
        - 릴레이션이 분해되기 전에는 조인이 필요없는 질의가 분해 후에는 조인을 필요로 하는 질의로 바뀔 수 있음
        - 분해된 릴레이션들을 사용하여 원래 릴레이션을 재구성하지 못할 수 있음
    - ex) 좋은 예
    
    ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%2012.png)
    
    ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%2013.png)
    

### 제1정규형, 제2정규형, 제3정규형, BCNF

- **제1정규형**
    - 한 릴레이션 R이 제1정규형을 만족할 필요 충분 조건은 릴레이션 R의 모든 애트리뷰트가 원자값만을 갖는다는 것
    - 즉, 릴레이션의 모든 애트리뷰트에 **반복 그룹(repeating group)** 이 나타나지 않으면 제1정규형을 만족
    (반복 그룹 ⇒ `{A, B}` , 원자값이여함)
        
        ![Untitled](7%20%E1%84%83%E1%85%A1%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%206f94d9f9d7644e4395d2aed9a41bf358/Untitled%2014.png)
        
    - **갱신 이상**
        - 수정이상 : 학과 이름을 수정하면 다 수정해야함
        - 삭제이상 : 학과에 소속된 학생이 없을 경우 삭제 할 수 없응ㅁ
        - 삽입 이상 : 학생이 다른 학과에 들어가면 데이터 중복 발
- **제2정규형**